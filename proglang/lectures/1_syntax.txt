Syntax

==========

Specification:
	Syntax must be SPECIFIED, not only by examples, as examples 
	cannot show every general case.

	Informal Specification is expressed in NATURAL LANGUAGE

	Formal Specification is expresses in PRECISE NOTATION.
		More precise, concise.
		Less likely to be ambiguous, inconsistent, incomplete.
		Only accessible by those who understand notation
		Often difficult to define for a REAL PL.
	
	For example, INFORMAL:
		while-command: A while command consists of 'while'
			       followed by an expression within (),
			       followed by a command.
	vs. FORMAL:
		while-command = 'while' '(' expression ')' command
	
	
	Notation:
		Regular Expressions: Specify syntax of 'lexical' elements.
				     e.g. identifiers, literals, comments

		Backus Naur Form (BNF): Specify syntax of larger/nested
					programming constructs.
					e.g. expressions, commands, decl.
		
		Extended ditto. (EBNF): Combines BNF & RE, good for almost all.

Regular Expressions (SEE ~/uni/algs for REGEX):
------------------------------------------------
REs match a set of strings (can be inf)

...?: Either empty string or any string matched by RE. I.e. ... | 3
...+: Matches concat of 1+ strings, each of which matched by ...
      i.e. (...)(...)*

Examples:
	'M'('r'|'rs'|'iss') - M followed by either r, rs, or iss.
	'b'('an')*'a' - b followed by 0+ 'an' ending in 'a'
	('x'|'abc')* - 0+ 'x', or 0+ 'abc'

Unix shell uses adhoc pattern match:
	[...] match any of enclosed chars.
	? matches any single char
	* matchs any 0+ string of chars.
	(restricted variable of RE)

	e.g. bat.[chp] prints bat.c, bat.h, bat.p
	     bat.? prints bat.x for all x present.
	     *.c prints all files ending in .c

egrep, a unix util, uses FULL NOTATION.
	All normal RE included
	Also include extensions: [...] like sh, also . for any 1 char.

	e.g. egrep b[aei]t file: Finds all lines containing bat,bit,bet in file.
	     egrep b.t file: ditto but any char.
	     egrep b(an)*a file: Finds all lines containing b, 0+ 'ab', a

Limitations of RE:
	RE's correspond to FSA, see ~/uni/algs notes. 

	In every PL, expressions can be nested.
	In most PL, commands can be nested.

	This requires a 'Context Free Grammar'.

Grammars:
------------
Grammars are a set of rules, specifying how 'phrases' are formed in a given lang.
Each rule specifies formulation from symbols (words, punctuation) and sub-phrases

Ex: Mini English
	'I smell a rat'
	-> 'I', 'smell', 'a', 'rat' :: Terminal Symbols
	-> sentence, subject, object, noun, verb :: Non-Terminal Symbols
	
	sentence = subject verb object '.'
	subject = 'I' | 'a' noun | 'the' noun (I or a noun or the noun)
	object = 'me' | 'a' noun | 'the' noun (me, or a noun, or the noun)
	noun = 'rat'
	verb = 'smell'
	
	^^^ The above are 'productions' for non-terminal symbols in BNF.
	    Non-Terminal symbols must be producible from terminal.

	Hence 'I smell a rat' -> I(s) smell(v) 'a' rat(n) = sentence

A CONTEXT FREE GRAMMAR is made of:
	Terminal Symbols, Non-Terminal Symbols
	A sentence symbol
	A set of production rules.

Backus Naur Form (notation for grammar)
----------------------------------------
Defines production rules, see above examples.

i.e. N = a where N is nonterminal, and a is seq of 1+ nonterminal/terminal symbols.
				            or set of OR

Phrase Structure & Syntax Trees:
---------------------------------
A grammar defines how phrases may be formed from sub-phrases. (Phrase Structure)
Every phrase in the language, has a syntax tree that represents its ^^^^^

see 1_5_EX_Calc.txt.

Consider a grammar G.
A syntax tree of G is a tree where:
	every terminal node is labeled by a terminal symbol of G
	every N-term node is labeled by a n-term symbol of G
	A NT node N, may have children X,Y,Z (order important)
	             only if G has prod. rule N = ... | X Y Z | ...
	
If N is a NT symbol of G, a PHRASE of class N, is a string of T symbols labelling T
	nodes of syntax tree whose root node is N. 

	i.e. x*(22-y) is phrase of class expr. (also is phrase of prog)
	
	IN ENGLISH: For any non terminal symbol, phrases of it are strings including 
		    only the terminal symbols found at the leaves of the tree rooted
		    by the parent non-terminal symbol.

If S is the sentence symbol of G, a sentence of G is a phrase of class S.
The language generated by G is the set of all sentences of class S.

Ambiguity
----------
A phrase is ambiguous if it has +1 syntax tree.
A grammer is ambiguous if any phrases are.
Ambiguity is common in Natural Languages.
A grammer for a PL must be unambiguous, otherwise cannot define programs.

See dangling else ambiguity.

EBNF Notation
-------------
A combination of BNF & RE.
i.e. NT symbol = RE composed of T/NT symbols.

